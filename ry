#!/usr/bin/env bash
set -eou pipefail

V_arg=0
dash_arg=0
m_arg=0
c_arg=0
q_arg=0
file_arg=0
args=("$@")
for i in "${!args[@]}"
do
  if [[ ${args[$i]} == -h || ${args[$i]} == --help ]]; then
    cat << _EOT_
Usage: ry [option] ... [-c cmd | -m mod | file | -] [arg] ...
ry = mypy + isort + black + python, in one command

Without file argument:   Run ry recursively in the current directory
With one file argument:  Run ry on the provided file

You can't pass arguments to mypy, isort or black through ry, I use a
pyproject.toml: https://snarky.ca/what-the-heck-is-pyproject-toml/

Options and arguments:
-h     : print this message and exit (also ---help)
-q     : supresses non-error output from mypy, isort, black, and ry itself
[...]  : other options passed to ry are passed to python as expected
-c cmd : program passed in as string (terminates option list)
-m mod : run library module as a script (terminates option list)
file   : program read from script file
-      : program read from stdin (default; interactive mode if a tty)
arg    : arguments passed to program in sys.argv[1:]

Environment variable:
RY     : Location of Python3 command, if not set defaults to \`py\`
_EOT_
    exit 0
  fi

  if [[ ${args[$i]} == - ]]; then
    dash_arg=1
  fi

  if [[ ${args[$i]} == -m ]]; then
    m_arg=1
  fi

  if [[ ${args[$i]} == -c ]]; then
    c_arg=1
  fi

  if [[ ${args[$i]} == -q ]]; then
    q_arg=1
  fi

  if [[ ${args[$i]} == -V ]]; then
    # python3 -V and python3 -V -V do different things
    V_arg=$(( V_arg + 1 ))
  fi

  if [[ ${args[$i]} == *.py ]]; then
    file_arg=1
    pre_file_args=${args[@]:0:$i}
    file=${args[$i]}
    post_file_args=${args[@]:$i + 1:${#args[@]}}
    break
  fi
done

arg_sum=$(( $dash_arg + $m_arg + $c_arg + $file_arg))
if [[ $arg_sum -gt 1 ]]; then
  echo -c, -m, *.py, - args mutually exclusive
  exit 1
fi

if [[ $RY == "" ]]; then
  echo RY env variable not set, default-ing to py
  RY="py"
fi

if [[ -z ${RY+ryryryry} ]]; then # ryryryry is a random string
  # RY env variable is unset
  echo 'Error: RY environment variable not set' >&2
  echo ry attempting to use py https://github.com/brettcannon/python-launcher
  RY="py"
  if ! [ -x "$(command -v py)" ]; then
    # py command doesn't exist
    echo 'Error: ry depends on py but it is not installed' >&2
    echo ry defaulting to system python3 install
    RY="python3"
  fi
fi

if [[ $V_arg -eq 1 ]]; then
    $RY -V
    exit 0
  elif [[ $V_arg -ge 2 ]]; then
    $RY -V -V
    exit 0
fi

if [[ $q_arg -eq 1 ]]
  then
    # quiet flag is the same for python3, isort, and black
    # mypy doesn't have a quiet flag :( see workaround below
    quiet_flag="-q"
  else
    quiet_flag=""
fi

if [[ $dash_arg -eq 1 ]]; then
  tty_cmd="$RY $quiet_flag -"
  if [[ $q_arg -eq 0 ]]; then
    echo + $tty_cmd
  fi
  $tty_cmd
  exit
fi


if [[ $c_arg -eq 1 || $m_arg -eq 1 ]]; then
  # if [[ $q_arg -eq 0 ]]; then
  #   # BUG echo doesn't preserve quotes, superficial only
  #   echo + $RY "$@"
  # fi
  # set -x
  $RY "$@"
  exit
fi


run_mypy () {
  if [[ $q_arg -eq 0 ]]; then
      printf "+ $RY -m mypy $1\n"
  fi

  set +e
  # not using local so exit code reflects mypy
  mypy_output=$($RY -m mypy --pretty $1)
  mypy_exit_code=$?
  set -e

  if [[ $mypy_exit_code -eq 0 && $q_arg -eq 0 ]]
  then
    printf "$mypy_output\n"
  fi

  if [[ $mypy_exit_code -eq 1 ]]
  then
    printf "$mypy_output\n"
    exit 1
  fi
}

set_x_if_allowed() {
  if [[ $q_arg -eq 0 ]]; then
      set -x
  fi
}

if [[ $# -eq 0 ]] || \
[[ $# -eq 1 && $1 == -q ]]
  then
    run_mypy .
    set_x_if_allowed
    $RY -m isort $quiet_flag .
    $RY -m black $quiet_flag .
  else
    run_mypy $file
    set_x_if_allowed
    $RY -m isort $quiet_flag $file
    $RY -m black $quiet_flag $file
    # don't pass the quiet flag to python, I'm exploiting
    # the fact our quiet flag is the same as python's "-q"
    # so it's in pre_file_args already
    $RY $pre_file_args $file $post_file_args
fi
