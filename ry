#!/usr/bin/env bash
set -eou pipefail

py_version=""
py_version_arg=0
V_arg=0
dash_arg=0
m_arg=0
c_arg=0
q_arg=0
file_arg=0

args=("$@")
for i in "${!args[@]}"
do
  if [[ ${args[$i]} == -h || ${args[$i]} == --help ]]; then
    cat << _EOT_
Usage: ry [-X | -X.Y] [option] ... [-c cmd | -m mod | file | -] [arg] ...
ry = mypy + isort + black + py, in one command

Without file argument:   Run ry recursively in the current directory
With one file argument:  Run ry on the provided file

You can't pass arguments to mypy, isort or black through ry, I use a
pyproject.toml: https://snarky.ca/what-the-heck-is-pyproject-toml/

Options and arguments:
-[X]   : launch the latest Python X version (e.g. -3 for the latest Python 3)
-[X.Y] : launch the specified Python version (e.g. -3.6 for Python 3.6)
-h     : print this message and exit (also ---help)
-q     : supresses non-error output from mypy, isort, black, and ry itself
[...]  : other options passed to ry are passed to python as expected
-c cmd : program passed in as string (terminates option list)
-m mod : run library module as a script (terminates option list)
file   : program read from script file
-      : program read from stdin (default; interactive mode if a tty)
arg    : arguments passed to program in sys.argv[1:]
_EOT_
    exit 0
  fi

  if [[ ${args[$i]} == - ]]; then
    dash_arg=1
  fi

  if [[ ${args[$i]} =~ -[3-4]\.?[0-9]{0,2} ]]; then
    py_version_arg=1
    py_version=${args[$i]}
  fi

  if [[ ${args[$i]} == -m ]]; then
    m_arg=1
  fi

  if [[ ${args[$i]} == -c ]]; then
    c_arg=1
  fi

  if [[ ${args[$i]} == -q ]]; then
    q_arg=1
  fi

  if [[ ${args[$i]} == -V ]]; then
    # python3 -V and python3 -V -V do different things
    V_arg=$(( V_arg + 1 ))
  fi

  if [[ ${args[$i]} == *.py ]]; then
    file_arg=1
    pre_file_args=${args[@]:0:$i}
    file=${args[$i]}
    post_file_args=${args[@]:$i + 1:${#args[@]}}
    break
  fi
done

arg_sum=$(( $dash_arg + $m_arg + $c_arg + $file_arg))
if [[ $arg_sum -gt 1 ]]; then
  echo -c, -m, *.py, - args mutually exclusive
  exit 1
fi

if ! [ -x "$(command -v py)" ]; then
  echo 'Error: ry depends on py but it is unavailable (see, https://github.com/brettcannon/python-launcher)' >&2
  exit 1
fi

if [[ $py_version_arg -eq 1 ]]; then
  RY="py $py_version"
else
  RY="py"
fi

if [[ $V_arg -eq 1 ]]; then
    $RY -V
    exit 0
  elif [[ $V_arg -ge 2 ]]; then
    $RY -V -V
    exit 0
fi

if [[ $q_arg -eq 1 ]]
  then
    # quiet flag is the same for python3, isort, and black
    # mypy doesn't have a quiet flag :( see workaround below
    quiet_flag="-q"
  else
    quiet_flag=""
fi

if [[ $dash_arg -eq 1 ]]; then
  tty_cmd="$RY $quiet_flag -"
  if [[ $q_arg -eq 0 ]]; then
    echo + $tty_cmd
  fi
  $tty_cmd
  exit
fi


if [[ $c_arg -eq 1 || $m_arg -eq 1 ]]; then
  # if [[ $q_arg -eq 0 ]]; then
  #   # BUG echo doesn't preserve quotes, superficial only
  #   echo + $RY "$@"
  # fi
  # set -x
  $RY "$@"
  exit
fi


run_mypy () {
  if [[ $q_arg -eq 0 ]]; then
      printf "+ $RY -m mypy $1\n"
  fi

  set +e
  # not using local so exit code reflects mypy
  mypy_output=$($RY -m mypy --pretty $1)
  mypy_exit_code=$?
  set -e

  if [[ $mypy_exit_code -eq 0 && $q_arg -eq 0 ]]
  then
    printf "$mypy_output\n"
  fi

  if [[ $mypy_exit_code -eq 1 ]]
  then
    printf "$mypy_output\n"
    exit 1
  fi
}

set_x_if_allowed() {
  if [[ $q_arg -eq 0 ]]; then
      set -x
  fi
}

if [[ $# -eq 0 ]] || \
[[ $# -eq 1 && ( $q_arg -eq 1 || $py_version_arg -eq 1 ) ]] || \
[[ $# -eq 2 && ( $q_arg -eq 1 && $py_version_arg -eq 1 ) ]]
  then
    run_mypy .
    set_x_if_allowed
    $RY -m isort $quiet_flag .
    $RY -m black $quiet_flag .
  else
    run_mypy $file
    set_x_if_allowed
    $RY -m isort $quiet_flag $file
    $RY -m black $quiet_flag $file
    # Two things:
    # 1) don't pass the quiet flag to python, I'm exploiting
    #    the fact our quiet flag is the same as python's -q
    #    so it's in pre_file_args already
    # 2) don't pass RY as normal, the version is already in
    #    pre_file_args so you'll double pass that argument
    #    that's why we just use py here
    py $pre_file_args $file $post_file_args
fi
